#!/usr/bin/env ruby
# encoding: UTF-8
$: << File.dirname(__FILE__) + '/../lib'

require 'cucumber/platform'
require 'cucumber/ast'
require 'cucumber/feature_file'
require 'cucumber/formatter/ansicolor'

module Cucumber
  module Result
    class Passed
      def to_s
        "✓"
      end

      def describe_to(visitor, *args)
        visitor.passed(*args)
      end
    end

    class Failed
      attr_reader :exception

      def initialize(exception)
        @exception = exception
      end

      def to_s
        "✗ (#{@exception.message})"
      end

      def describe_to(visitor, *args)
        visitor.failed(*args)
      end
    end
  end

  module Testable
    def self.new_scenario(*args)
      Scenario.new(*args)
    end

    def self.new_examples_table_row(*args)
      ExamplesTableRow.new(*args)
    end

    def self.new_step(*args)
      Step.new(*args)
    end

    class Step
      attr_reader :result

      def initialize(step)
        @step = step
      end

      def execute(runtime, report, result_listener)
        report.before_step(step)
        step_match = runtime.step_match(step.name)
        step_match.invoke(step.multiline_arg)
        self.result = Result::Passed.new
      rescue => e
        self.result = Result::Failed.new(e)
      ensure
        report.after_step(step, result)
        result.describe_to(result_listener, step, result)
      end

      private

      attr_reader :step
      attr_writer :result
    end

    class Scenario

      def initialize(feature, background, scenario)
        @feature, @background, @scenario = feature, background, scenario
      end

      def describe_source_to(visitor, *args)
        scenario.describe_to(visitor, *args)
      end

      def describe_result_to(visitor, *args)
        result.describe_to(visitor, *args)
      end

      def execute(runtime, report)
        report.before_test(self)
        runtime.with_hooks(scenario) do
          steps.each do |step|
            execute_step(runtime, report, step)
          end
        end
        report.after_test(self)
      end

      def failed(step, result)
        @result = Result::Failed.new(result.exception)
      end

      def passed(step, result)
        @result = Result::Passed.new
      end

      private

      attr_reader :result, :feature, :background, :scenario

      def execute_step(runtime, report, step)
        step.execute(runtime, report, self)
      end

      def steps
        return @steps if @steps
        steps = background.raw_steps + scenario.raw_steps
        @steps ||= steps.map do |step|
          Testable.new_step(step)
        end
      end
    end

    class ExamplesTableRow
      attr_reader :feature, :background, :scenario_outline

      def initialize(feature, background, scenario_outline, examples_table, examples_table_row)
        @feature, @background, @scenario_outline = feature, background, scenario_outline
      end

      def describe_to(visitor, *args)
        visitor.executable_examples_table_row(self, *args)
      end

      def execute(*args)
        # noop
      end

      def result
        Result::Failed.new
      end

    end
  end

  # Walks the AST and emits Tests
  # from scenarios or example table rows
  class Compiler
    def initialize(testable, &on_new_test_ready)
      @on_new_test_ready = on_new_test_ready
      @testable = testable
    end

    def feature(feature)
      @current_feature = feature
      yield
    end

    def background(background)
      @current_background = background
      yield
    end

    def scenario_outline(scenario_outline)
      @current_scenario_outline = scenario_outline
      yield
    end

    def examples_table(examples_table)
      @current_examples_table = examples_table
      yield
    end

    def examples_table_row(examples_table_row)
      new_examples_table_row(current_feature, current_background, current_scenario_outline, current_examples_table, examples_table_row)
    end

    def scenario(scenario)
      new_scenario(current_feature, current_background, scenario)
    end

    private

    attr_reader :testable

    def new_examples_table_row(*args)
      new_test_ready testable.new_examples_table_row(*args)
    end

    def new_scenario(*args)
      new_test_ready testable.new_scenario(*args)
    end

    def new_test_ready(test)
      @on_new_test_ready.call test
    end

    attr_reader :current_feature, :current_background, :current_scenario_outline, :current_examples_table
  end

  require 'ansi' # gem install ansi
  class PrettyPrinter
    include Cucumber::Formatter::ANSIColor

    def feature(feature)
      print_feature_name(feature)
    end

    def scenario(scenario)
      puts
      puts "    # #{grey(scenario.location)}"
      puts "    #{scenario.keyword}: #{scenario.title}"
    end

    def step(step, result=nil)
      indent = "      "
      unless result
        print indent + grey(format_step(step))
      else
        print ANSI::Code.up +
          indent +
          result.describe_to(self, "#{result} #{format_step(step)}")
      end
    end

    def print(message)
      puts message
    end

    private

    def format_step(step)
      "#{step.keyword}#{step.name}"
    end

    def print_feature_name(feature)
      return if feature == current_feature
      @current_feature = feature
      puts
      puts "  # #{grey(feature.location)}"
      puts "  #{feature.keyword}: #{feature.title}"
    end

    def color(result, text)
      result.describe_to(self, text)
    end

    attr_reader :current_feature
  end

  class PrettyConsoleReport
    def initialize(printer)
      @printer = printer
    end

    def before_tests
      @summary = ScenarioResultSummary.new
    end

    # test is either a Testable::Scenario or a Testable::ExamplesTableRow
    def before_test(test)
      # call describe_to on the source AST node (Scenario or ExamplesTableRow)
      test.describe_source_to(@printer)
    end

    # step is the AST step
    def before_step(step)
      step.describe_to(@printer)
    end

    # step is the AST step
    def after_step(step, result)
      step.describe_to(@printer, result)
    end

    def after_test(test)
      test.describe_result_to(@summary)
    end

    def after_tests
      @printer.print(@summary.to_s)
    end

    class ScenarioResultSummary
      def initialize
        @total_failed = 0
        @total_passed = 0
      end

      def passed(*args)
        @total_passed += 1
      end

      def failed(*args)
        @total_failed += 1
      end

      def to_s
        total = @total_passed + @total_failed
        "#{total} scenarios run. #{@total_passed} passed, #{@total_failed} failed"
      end
    end

  end

  require 'cucumber/runtime'
  require 'cucumber'
  runtime = Cucumber::Runtime.new
  runtime.load_programming_language('rb')
  runtime.support_code.load_files!(Dir['features/**/*.rb'])

  report = PrettyConsoleReport.new(PrettyPrinter.new)

  compiler = Compiler.new(Testable) do |executable|
    executable.execute(runtime, report)
  end
  files = Dir['features/docs/**/*.feature']

  report.before_tests
  files.each do |path|
    feature = FeatureFile.new(path).parse([], {})
    feature.describe_to(compiler)
  end
  report.after_tests

end
