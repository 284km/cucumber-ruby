#!/usr/bin/env ruby
# encoding: UTF-8
$: << File.dirname(__FILE__) + '/../lib'

require 'cucumber/platform'
require 'cucumber/ast'
require 'cucumber/feature_file'
require 'cucumber/formatter/ansicolor'

module Cucumber
  module Result
    class Passed
      def to_s
        "✓"
      end

      def describe_to(visitor, *args)
        visitor.passed(*args)
      end
    end

    class Unknown
      def to_s
        "○"
      end

      def describe_to(visitor, *args)
        visitor.unknown(*args)
      end
    end

    class Failed
      attr_reader :exception

      def initialize(exception)
        @exception = exception
      end

      def to_s
        "✗ (#{@exception.message})"
      end

      def describe_to(visitor, *args)
        visitor.failed(*args)
      end
    end
  end

  module Testable
    def self.new_scenario(*args)
      Scenario.new(*args)
    end

    def self.new_examples_table_row(*args)
      ExamplesTableRow.new(*args)
    end

    def self.new_step(*args)
      Step.new(*args)
    end

    class Step
      attr_reader :result

      def initialize(step)
        @step = step
      end

      def execute(runtime, report, result_listener)
        report.before_step(step)
        step_match = runtime.step_match(step.name)
        step_match.invoke(step.multiline_arg)
        self.result = Result::Passed.new
      rescue => e
        self.result = Result::Failed.new(e)
      ensure
        report.after_step(step, result)
        result.describe_to(result_listener, step, result)
      end

      private

      attr_reader :step
      attr_writer :result
    end

    class Scenario
      def initialize(feature, background, scenario)
        @feature, @background, @scenario = feature, background, scenario
        raise ArgumentError unless feature
        raise ArgumentError unless background
        raise ArgumentError unless scenario
        @result = Result::Unknown.new
      end

      # begin runtime API
      def language
        scenario.language
      end

      def accept_hook?(hook)
        scenario.accept_hook?(hook)
      end

      # this is how the runtime tell us a hook has failed
      def fail!(exception)
        mark_as_failed(exception)
      end
      # end runtime API

      def describe_to(visitor, *args)
        attributes = [
          feature,
          background,
          scenario,
          result
        ]
        attributes.each do |attribute|
          attribute.describe_to(visitor, *args)
        end
      end

      def execute(runtime, report)
        report.before_test(self)
        # TODO: get the hooks from runtime and compile them into our list of steps
        runtime.with_hooks(self) do
          testable_steps.each do |testable_step|
            testable_step.execute(runtime, report, self)
          end
        end
        report.after_test(self)
      end

      def failed(step, result)
        mark_as_failed(result.exception)
      end

      def passed(step, result)
        @result = Result::Passed.new
      end

      private

      attr_reader :result, :feature, :background, :scenario

      def mark_as_failed(exception)
        @result = Result::Failed.new(exception)
      end

      def testable_steps
        return @testable_steps if @testable_steps
        raw_steps = background.raw_steps + scenario.raw_steps
        @testable_steps ||= raw_steps.map do |step|
          Testable.new_step(step)
        end
      end
    end

    class ExamplesTableRow
      attr_reader :feature, :background, :scenario_outline, :examples_table, :examples_table_row

      def initialize(feature, background, scenario_outline, examples_table, examples_table_row)
        @feature, @background, @scenario_outline, @examples_table, @examples_table_row = \
          feature, background, scenario_outline, examples_table, examples_table_row
      end

      def describe_to(visitor, *args)
        attributes = [
          feature,
          background,
          scenario_outline,
          examples_table,
          examples_table_row,
          result
        ]
        attributes.each do |attribute|
          attribute.describe_to(visitor, *args)
        end
      end

      def execute(runtime, report)
        report.before_test(self)
        # noop
        report.after_test(self)
      end

      def result
        Result::Failed.new(StandardError.new("Can't execute examples table rows yet"))
      end

    end
  end

  require 'ansi' # gem install ansi
  class PrettyPrinter
    include Cucumber::Formatter::ANSIColor

    def feature(feature, *)
      for_new(:feature, feature) do
        print_keyword feature, 1
      end
    end

    def background(background, *)
      for_new(:background, background) do
        print_keyword background, 2
      end
    end

    def scenario(scenario, *)
      for_new(:scenario, scenario) do
        print_keyword scenario, 2
      end
    end

    def scenario_outline(scenario_outline)
      for_new(:scenario_outline, scenario_outline) do
        print_keyword scenario_outline, 2
        # TODO: print steps
      end
    end

    def examples_table(examples_table)
      for_new(:examples_table, examples_table) do
        print_keyword examples_table, 3
      end
    end

    def test_case(*args)
      yield
    end

    def examples_table_row(row)
      puts row.to_s
    end

    def step(step, result=nil)
      indent = "      "
      unless result
        print indent + grey(format_step(step))
      else
        print ANSI::Code.up +
          indent +
          result.describe_to(self, "#{result} #{format_step(step)}")
      end
    end

    def print(message)
      puts message
    end

    def unknown
    end

    private

    def print_keyword(node, indent_size)
      indent = ' ' * indent_size * 2
      puts
      puts "#{indent}# #{grey(node.location)}"
      puts "#{indent}#{node.keyword}: #{node.title}"
    end

    def for_new(node_type, value)
      @current ||= {}
      return if @current[node_type] == value
      @current[node_type] = value
      yield
    end

    def color(result, text)
      result.describe_to(self, text)
    end

    def format_step(step)
      "#{step.keyword}#{step.name}"
    end


    attr_reader :current_feature
  end

  class PrettyConsoleReport
    def initialize(printer)
      @printer = printer
      @summary = ScenarioResultSummary.new
    end

    def before_test_suite
      @summary = ScenarioResultSummary.new
    end

    def before_test_case(test_case)
      test_case.describe_to(@printer)
    end

    def before_test_step(step)
      step.describe_to(@printer)
    end

    def after_test_step(step, result)
      step.describe_to(@printer, result)
    end

    def after_test_case(test_case, result)
      result.describe_to(@summary)
    end

    def after_test_suite
      @printer.print(@summary.to_s)
    end

    class ScenarioResultSummary
      def initialize
        @total_failed = 0
        @total_passed = 0
      end

      def passed(*args)
        @total_passed += 1
      end

      def failed(*args)
        @total_failed += 1
      end

      [
        :feature,
        :background,
        :scenario,
        :scenario_outline,
        :examples_table,
        :examples_table_row
      ].each do |ignored_message|
        define_method(ignored_message) { |*args| }
      end

      def test_case(*)
      end

      def to_s
        total = @total_passed + @total_failed
        "#{total} scenarios run. #{@total_passed} passed, #{@total_failed} failed"
      end
    end

  end

  feature_files = Dir['features/**/*.feature']
  #feature_files = Dir["fixtures/self_test/features/outline_sample.feature"]
  #support_files = Dir['fixtures/self_test/features/**/*.rb']

  report = PrettyConsoleReport.new(PrettyPrinter.new)

  require 'cucumber/core'
  extend Cucumber::Core

  features = feature_files.map do |file|
    parse_gherkin File.read(file)
  end

  test_suite = compile(features)

  require 'cucumber/runtime'
  require 'cucumber'
  mappings = Class.new do
    def support_files
      Dir['features/**/*.rb']
    end

    def runtime
      result = Cucumber::Runtime.new
      result.load_programming_language('rb')
      result.support_code.load_files!(support_files)
      result
    end

    def execute(step)
      step_match = runtime.step_match(step.name)
      step_match.invoke(step.multiline_arg)
    end
  end.new

  execute(test_suite, mappings, report)
end
