#!/usr/bin/env ruby
# encoding: UTF-8
$: << File.dirname(__FILE__) + '/../lib'
$: << File.dirname(__FILE__) + '/../../cucumber-ruby-core/lib'

require 'cucumber/platform'
require 'cucumber/ast'
require 'cucumber/feature_file'
require 'cucumber/formatter/ansicolor'

module Cucumber

  require 'cucumber/formatter/progress'
  require 'cucumber/formatter/pretty'
  class LegacyFormatterReport
    def initialize(runtime, legacy_formatter_type, options)
      @runtime = runtime
      @formatter = legacy_formatter_type.new(runtime, STDOUT, options)
    end

    def before_test_case(test_case)
<<<<<<< HEAD
      @original.before_feature_element(:element)

      printer = ScenarioPrinter.new(@original)
      test_case.describe_source_to(printer)
    end

    def after_test_case(test_case, result)
      builder = LegacyResultBuilder.new
      result.describe_to(builder)
      @runtime.record_result(builder.scenario)

      @original.after_feature_element(:element)
    end

    def before_test_step(step)
    end

    def after_test_step(step, result)
      builder = LegacyResultBuilder.new
      result.describe_to(builder)
      step_result = builder.step_result
      @runtime.step_visited(step_result)
      @original.before_step_result(step_result)
      printer = StepPrinter.new(@original, @runtime, step_result)
      step.describe_source_to(printer)
      @original.after_step_result(step_result) if @original.respond_to?(:after_step_result)
    end

    def after_suite
      @original.after_features(nil)
    end

    class ScenarioPrinter
      def initialize(report)
        @report = report
=======
      formatter.before_feature_element(:element)
      test_case.describe_source_to(source_printer)
    end

    def after_test_case(test_case, result)
      record_test_case_result(result)
      formatter.after_feature_element(:element)
    end

    def before_test_step(step)
    end

    def after_test_step(step, result)
      record_step_result(result) do |step_result|
        formatter.before_step_result(step_result)
        step.describe_source_to(source_printer, runtime, step_result)
        formatter.after_step_result(step_result) if formatter.respond_to?(:after_step_result)
>>>>>>> Improving the spike formatter:
      end
    end

    def after_suite
      formatter.after_features(nil)
    end

    private

    def case_result(result)
    end

<<<<<<< HEAD
      def scenario_outline(scenario_outline)
      end

      def examples_table(examples)
      end

      def examples_table_row(row)
      end

      def background(background)
      end

      def step(step)
      end
=======
    def source_printer
      @source_printer ||= SourcePrinter.new(formatter)
    end

    def record_test_case_result(result)
      scenario = LegacyResultBuilder.new(result).scenario
      runtime.record_result(scenario)
      yield scenario if block_given?
    end

    def record_step_result(result)
      step_result = LegacyResultBuilder.new(result).step_result
      runtime.step_visited(step_result)
      yield step_result if block_given?
    end

    def formatter
      @formatter
>>>>>>> Improving the spike formatter:
    end

    def runtime
      @runtime
    end

    SourcePrinter = Struct.new(:formatter) do
      def hook(*)
      end

      def feature(feature, *)
        return if feature == @current_feature
        formatter.before_feature(feature)
        formatter.feature_name(feature.keyword, feature.name)
        @current_feature = feature
      end

      def scenario(scenario, *)
        return if scenario == @current_scenario
        source_indent = 1 # TODO
        formatter.scenario_name(scenario.keyword, scenario.name, scenario.location.to_s, source_indent)
        @current_scenario = scenario
      end

      def background(background, *)
        return if background == @current_background
        source_indent = 1 #Â TODO
        formatter.background_name(background.keyword, background.name, background.location.to_s, source_indent)
        @current_background = background
      end

<<<<<<< HEAD
      def step(step)
        # TODO: How else can we get this?
        step_match = @runtime.step_match(step.name)
        @report.step_name(step.keyword, step_match, @step_result.status, :source_indent, :background, :file_colon_line)
      end

      def scenario_outline(scenario_outline)
      end

      def examples_table(examples)
      end

      def examples_table_row(row)
=======
      def step(step, runtime, step_result)
        step_match = runtime.step_match(step.name)
        source_indent = 1 # TODO
        formatter.step_name(step.keyword, step_match, step_result.status, source_indent, :background, step.location.to_s)
      end

      def scenario_outline(*)
        puts "TODO: scenario outline"
      end

      def examples_table(*)
        puts "TODO: examples table"
      end

      def examples_table_row(*)
        puts "TODO: examples table row"
>>>>>>> Improving the spike formatter:
      end
    end

    require 'cucumber/ast/step_result'
    class LegacyResultBuilder
      def initialize(result)
        result.describe_to(self)
      end

      def passed
        @status = :passed
      end

      def failed
        @status = :failed
      end

      def undefined
        @status = :undefined
      end

      def skipped
        @status = :skipped
      end

      def exception(exception, *)
        @exception = exception
      end

      def duration(*); end

      def step_result
        Ast::StepResult.new(:keyword, :step_match, :multiline_arg, @status, @exception, :source_indent, :background, :file_colon_line)
      end

      def scenario
        LegacyScenario.new(@status)
      end

      LegacyScenario = Struct.new(:status)
    end

  end

  features_glob = ARGV[0] || 'features/**/*.feature'
  feature_files = Dir[features_glob].reject { |f| f =~ /iso-8859-1/ }
  puts "Running features:"
  p feature_files

  require 'cucumber/core'
  extend Cucumber::Core

  require 'cucumber/core/gherkin/document'
  features = feature_files.map do |file|
    Cucumber::Core::Gherkin::Document.new(file, File.read(file))
  end

  require 'cucumber/runtime'
  require 'cucumber'
  class ClassicMappings

    def test_step(step, mapper)
      step_match = runtime.step_match(step.name)
      mapper.map { step_match.invoke(step.multiline_arg) }
    rescue Cucumber::Undefined
    end

    def test_case(test_case, mapper)
      scenario = Scenario.new(test_case)
      mapper.before do
        ruby.begin_rb_scenario(scenario)
      end
      ruby.hooks_for(:before, scenario).each do |hook|
        mapper.before do
          hook.invoke('location', scenario)
        end
      end
      ruby.hooks_for(:after, scenario).each do |hook|
        mapper.after do
          hook.invoke('location', scenario)
        end
      end
    end

    def runtime
      return @runtime if @runtime
      result = Cucumber::Runtime.new
      result.support_code.load_files!(support_files)
      @runtime = result
    end

    private

    def ruby
      @ruby ||= runtime.load_programming_language('rb')
    end

    def support_files
      Dir['features/**/*.rb']
    end

    # adapts our test_case to look like the Cucumber Runtime's Scenario
    class Scenario
      def initialize(test_case)
        @test_case = test_case
      end

      def accept_hook?(hook)
        hook.tag_expressions.all? { |expression| @test_case.match_tags?(expression) }
      end

      def language
        @test_case.language
      end
    end
  end

  mappings = ClassicMappings.new
  formatter_options = {
    skip_profile_information: true,
    source: true,
  }
  report = LegacyFormatterReport.new mappings.runtime, Cucumber::Formatter::Pretty, formatter_options

  require 'cucumber/core/test/tag_filter'
  report = Class.new do
    def before_test_case(test_case)
      puts
      puts test_case.inspect
    end

    def after_test_case(test_case, result)
    end

    def before_test_step(test_step)
      puts '  ' + test_step.inspect
    end

    def after_test_step(test_step, result)
    end

    def after_suite
    end
  end.new
  execute features, mappings, report, [[Cucumber::Core::Test::TagFilter, ['~@jruby']]]
  report.after_suite
end
