require 'cucumber/ast/tags'

module Cucumber
  module Parser
    # TIP: When you hack on the grammar, just delete feature.rb in this directory.
    # Also make sure you have uninstalled all cucumber gems (don't forget xxx-cucumber
    # github gems).
    #
    # Treetop will then generate the parser in-memory. When you're happy, just generate
    # the rb file with tt feature.tt
    grammar Feature

      rule feature_sub
        white 
        comment 
        white 
        tags 
        white 
        header:(!(scenario_outline / scenario / background) .)* 
        bg:background? 
        feature_elements
        comment? {
          def emit(builder, filter)
            if(filter.nil? || feature_elements.accept?(filter) || (!bg.empty? && filter.accept?(bg)))
              comment.emit(builder)
              tags.emit(builder)
              builder.feature('', header.text_value, header.line)
              bg.emit(builder, filter) if bg.respond_to?(:emit)
              feature_elements.emit(builder, filter)
            end
          end
        }
      end

      rule tags
        white ts:(tag (space/eol)+)* {
          def at_line?(line)
            ts.elements.detect{|e| e.tag.line == line}
          end

          def tag_names
            @tag_names ||= ts.elements.map{|e| e.tag.text_value}
          end

          def emit(builder)
            ts.elements.each{|e| builder.tag(e.tag.text_value, e.tag.line)}
          end
        }
      end

      rule tag
        '@' [^@\r\n\t ]+
      end

      rule comment
        (comment_line white)* {
          def emit(builder)
            builder.comment(text_value, line)
          end
        }
      end

      rule comment_line
        space* '#' line_to_eol
      end

      rule background
        comment white background_keyword space* name:lines_to_keyword? (eol+ / eof) steps {
          def matches_name?(regexp_to_match)
            name.build =~ regexp_to_match
          end

          def at_line?(line)
            background_keyword.line == line ||
            steps.at_line?(line)
          end

          def matches_tags?(tag_expression)
            tag_expression.eval(self.parent.tags.tag_names)
          end

          def emit(builder, filter)
            builder.background(background_keyword.text_value, name.build, background_keyword.line)
            steps.emit(builder)
          end
        }
      end

      rule feature_elements
        (scenario / scenario_outline)* {
          def accept?(filter)
            filter.nil? || elements.empty? || elements.detect{|feature_element| filter.accept?(feature_element)}
          end
          
          def emit(builder, filter)
            elements.each do |feature_element|
              if filter.nil? || filter.accept?(feature_element)
                feature_element.emit(builder, filter)
              end
            end
          end
        }
      end

      rule scenario
        comment tags white scenario_keyword space* name:lines_to_keyword white steps white {
          def at_line?(line)
            scenario_keyword.line == line ||
            steps.at_line?(line) ||
            tags.at_line?(line)
          end

          def matches_tags?(tag_expression)
            feature_tag_names = self.parent.parent.tags.tag_names
            source_tag_names = (feature_tag_names + tags.tag_names).uniq
            tag_expression.eval(source_tag_names)
          end

          def matches_name?(regexp_to_match)
            name.build =~ regexp_to_match
          end

          def emit(builder, filter)
            comment.emit(builder)
            tags.emit(builder)
            builder.scenario(scenario_keyword.text_value, name.build, scenario_keyword.line)
            steps.emit(builder)
          end
        }
      end

      rule scenario_outline
        comment tags white scenario_outline_keyword space* name:lines_to_keyword white steps examples_sections white {
          def at_line?(line)
            outline_at_line?(line) ||
            examples_sections.at_line?(line) ||
            tags.at_line?(line)
          end

          def outline_at_line?(line)
            scenario_outline_keyword.line == line ||
            steps.at_line?(line)
          end

          def matches_tags?(tag_expression)
            feature_tag_names = self.parent.parent.tags.tag_names
            source_tag_names = (feature_tag_names + tags.tag_names).uniq
            tag_expression.eval(source_tag_names)
          end

          def matches_name?(regexp_to_match)
            outline_matches_name?(regexp_to_match) || examples_sections.matches_name?(regexp_to_match)
          end

          def outline_matches_name?(regexp_to_match)
            name.build =~ regexp_to_match
          end

          def emit(builder, filter)
            comment.emit(builder)
            tags.emit(builder)
            builder.scenario_outline(scenario_outline_keyword.text_value, name.build, scenario_outline_keyword.line)
            steps.emit(builder)
            examples_sections.emit(builder, filter, self)
          end
        }
      end

      rule steps
        step* {
          def at_line?(line)
            elements.detect{|e| e.at_line?(line)}
          end

          def emit(builder)
            elements.each{|e| e.emit(builder)}
          end
        }
      end

      rule step
        comment space* step_keyword space* name:line_to_eol (eol+ / eof) multi:multiline_arg? white {
          def at_line?(line)
            step_keyword.line == line ||
            (multi.respond_to?(:at_line?) && multi.at_line?(line))
          end

          def emit(builder)
            builder.step(step_keyword.text_value.strip, name.text_value.strip, step_keyword.line)
            multi.emit(builder) if multi.respond_to?(:emit)
          end
        }
      end

      rule examples_sections
        examples* {
          def at_line?(line)
            elements.detect { |e| e.at_line?(line) }
          end

          def matches_name?(regexp_to_match)
            elements.detect { |e| e.matches_name?(regexp_to_match) }
          end

          def emit(builder, filter, scenario_outline)
            elements.each do |e|
              if(filter.nil? || filter.accept_example?(e, scenario_outline))
                e.emit(builder, filter, scenario_outline)
              end
            end
          end
        }
      end

      rule examples
        comment space* examples_keyword space* name:lines_to_keyword? eol table white {
          def at_line?(line)
            examples_keyword.line == line ||
            table.at_line?(line)
          end

          def matches_tags?(tag_names)
            true
          end

          def outline_at_line?(line)
            true
          end

          def matches_name?(regexp_to_match)
            name.build =~ regexp_to_match
          end

          def emit(builder, filter, scenario_outline)
            builder.examples(examples_keyword.text_value, name.build, examples_keyword.line)
            table.emit(builder, filter, scenario_outline)
          end
        }
      end

      rule multiline_arg
        table / py_string
      end

      rule line_to_eol
        (!eol .)*
      end

      rule lines_to_keyword
        (!(eol space* reserved_words_and_symbols) .)* {
          def build
            self.text_value.split("\n").map{|s| s.strip}.join("\n")
          end
        }
      end

      rule reserved_words_and_symbols
        (step_keyword) / scenario_keyword / scenario_outline_keyword / table / tag / comment_line
      end

      rule white
        (space / eol)*
      end

    end
  end
end
