require 'cucumber/ast/tags'

module Cucumber
  module Parser
    # TIP: When you hack on the grammar, just delete feature.rb in this directory.
    # Also make sure you have uninstalled all cucumber gems (don't forget xxx-cucumber
    # github gems).
    #
    # Treetop will then generate the parser in-memory. When you're happy, just generate
    # the rb file with tt feature.tt
    grammar Feature

      rule feature_sub
        white 
        comment 
        white 
        tags 
        white 
        header:(!(scenario_outline / scenario / background) .)* 
        bg:background? 
        feature_elements
        comment? {
          def emit(listener)
            comment.emit(listener)
            tags.emit(listener)
            listener.feature('', header.text_value, header.line)
            bg.emit(listener) if bg.respond_to?(:emit)
            feature_elements.emit(listener)
          end
        }
      end

      rule tags
        white ts:(tag (space/eol)+)* {
          def tag_names
            @tag_names ||= ts.elements.map{|e| e.tag.text_value}
          end

          def emit(listener)
            ts.elements.each{|e| listener.tag(e.tag.text_value, e.tag.line)}
          end
        }
      end

      rule tag
        '@' [^@\r\n\t ]+
      end

      rule comment
        (comment_line white)* {
          def emit(listener)
            listener.comment(text_value, line)
          end
        }
      end

      rule comment_line
        space* '#' line_to_eol
      end

      rule background
        comment white background_keyword space* name:lines_to_keyword? (eol+ / eof) steps {
          def emit(listener)
            listener.background(background_keyword.text_value, name.build, background_keyword.line)
            steps.emit(listener)
          end
        }
      end

      rule feature_elements
        (scenario / scenario_outline)* {
          def emit(listener)
            elements.each do |feature_element|
              feature_element.emit(listener)
            end
          end
        }
      end

      rule scenario
        comment tags white scenario_keyword space* name:lines_to_keyword white steps white {
          def emit(listener)
            comment.emit(listener)
            tags.emit(listener)
            listener.scenario(scenario_keyword.text_value, name.build, scenario_keyword.line)
            steps.emit(listener)
          end
        }
      end

      rule scenario_outline
        comment tags white scenario_outline_keyword space* name:lines_to_keyword white steps examples_sections white {
          def emit(listener)
            comment.emit(listener)
            tags.emit(listener)
            listener.scenario_outline(scenario_outline_keyword.text_value, name.build, scenario_outline_keyword.line)
            steps.emit(listener)
            examples_sections.emit(listener, self)
          end
        }
      end

      rule steps
        step* {
          def emit(listener)
            elements.each{|e| e.emit(listener)}
          end
        }
      end

      rule step
        comment space* step_keyword space* name:line_to_eol (eol+ / eof) multi:multiline_arg? white {
          def emit(listener)
            listener.step(step_keyword.text_value.strip, name.text_value.strip, step_keyword.line)
            multi.emit(listener) if multi.respond_to?(:emit)
          end
        }
      end

      rule examples_sections
        examples* {
          def emit(listener, scenario_outline)
            elements.each do |e|
              e.emit(listener, scenario_outline)
            end
          end
        }
      end

      rule examples
        comment space* examples_keyword space* name:lines_to_keyword? eol table white {
          def emit(listener, scenario_outline)
            listener.examples(examples_keyword.text_value, name.build, examples_keyword.line)
            table.emit(listener, scenario_outline)
          end
        }
      end

      rule multiline_arg
        table / py_string
      end

      rule line_to_eol
        (!eol .)*
      end

      rule lines_to_keyword
        (!(eol space* reserved_words_and_symbols) .)* {
          def build
            self.text_value.split("\n").map{|s| s.strip}.join("\n")
          end
        }
      end

      rule reserved_words_and_symbols
        (step_keyword) / scenario_keyword / scenario_outline_keyword / table / tag / comment_line
      end

      rule white
        (space / eol)*
      end

    end
  end
end
